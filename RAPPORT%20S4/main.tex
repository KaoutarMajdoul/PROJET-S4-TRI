\documentclass[11pt]{article}
\usepackage[french]{babel}
\usepackage{natbib}
\usepackage{url}
\usepackage{tcolorbox}
\usepackage[utf8x]{inputenc}
\usepackage{amsmath}
\usepackage{graphicx}
\graphicspath{{images/}}
\usepackage{parskip}
\usepackage{fancyhdr}
\usepackage{vmargin}
    \usepackage[iso,french]{isodate}
        \usepackage{datetime}
\setmarginsrb{3 cm}{2.5 cm}{3 cm}{2.5 cm}{1 cm}{1.5 cm}{1 cm}{1.5 cm}

\title{Comparaison de tri en complexité linéaire}								% Title
					% Author
										

\makeatletter
\let\thetitle\@title

\let\thedate\@date
\makeatother

\pagestyle{fancy}
\fancyhf{}
\rhead{\theauthor}
\lhead{\thetitle}
\cfoot{\thepage}

\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{titlepage}
	\centering
    \vspace*{0.1 cm}
    \includegraphics[scale = 1.2]{logo.png}\\[3.0 cm]	% University Logo
    \textsc{\LARGE  Rapport de projet }\\[1.0 cm]	% University Name
 


\ddmmyyyydate \today

    
    
	\textsc{\Large Licence informatique }\\[0.5 cm]				% Course Code
	\rule{\linewidth}{0.2 mm} \\[0.4 cm]
	{ \huge \bfseries \thetitle}\\
	\rule{\linewidth}{0.2 mm} \\[1.5 cm]
	
	\begin{minipage}{0.4\textwidth}
		\begin{flushleft} \large
			\emph{Par :}\\
			MAJDOUL  Kaoutar\\
            CHAMROUK Laila\\
            MESSAOUDI Soukaina\\
            LAAFOU Ayoub\\
			\end{flushleft}
			\end{minipage}~
			\begin{minipage}{0.4\textwidth}
            
			\begin{flushright} \large
			\emph{Sous la direction de  :} \\
			M. GIROUDEAU\\
        
		\end{flushright}
        
	\end{minipage}\\[2 cm]
	
	
    
    
    
    
	
\end{titlepage}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\LARGE\textbf{Remerciement}\\ \vspace{0.5 cm}

\newpage

\LARGE\textbf{Introduction}\\ \vspace{0.5 cm}

\normalsize{Dans le cadre du projet se déroulant  [à completer]}





\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\tableofcontents

\newpage



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Présentation du projet}
\newpage

\section{Tri dénombrement}

\subsection{Description}



\hspace{1.0 cm} Afin de décrire l'algorithme de tri par dénombrement de manière formelle nous allons dérouler les différentes étapes avant d'obtenir un tableau de données trié. Tout d'abord, nous créons un tableau de \textit{n} valeurs aléatoires comprises entre deux valeurs choisies. Suite à cela nous parcourons le tableau et nous comptons le nombre de fois que chaque élément apparaît dans un tableau des effectifs \textit{E} dont la taille est la valeur maximum du tableau de départ et avec \textit{E[i] }le nombre de fois où le nombre \textit{i} apparaît dans le tableau.
Enfin nous le parcourrons dans le sens croissant et plaçons dans le tableau trié \textit{E[i]} fois l’élément \textit{i} avec \textit{i} allant de la plus petite valeur à la plus grande.





\hspace{1.0 cm} D'autre part, de manière informelle, le tri dénombrement est un algorithme de tri reposant sur le principe de construction d'un histogramme des données puis le balayage de celui-ci de façon croissante afin d'obtenir les données triées.
De ce fait, ici, plusieurs éléments identiques seront représentés par un unique élément quantifié. Ce tri convient exclusivement aux données constituées de nombres entiers compris entre une valeur minimale et une valeur maximale définies. Dans un souci d'efficacité, celles-ci doivent être assez proches l'une de l'autre et le nombre d'éléments doit être relativement grand afin d'obtenir une utilisation optimale de cette algorithme.

Ainsi, l'algorithme donne le psuedo-code suivant : \\

\begin{tcolorbox}
Créer un tableau \textit{T} de \textit{n} valeurs aléatoires bornées\\
Chercher l'élément maximum du tableau \\
 Créer un tableau \textit{E} de taille max + 1, initialisé à 0\\

Pour chaque élément du tableau de départ\\
\hspace*{1.0 cm} Incrémenter \textit{E[T[i]] }\\

Pour chaque élément du tableau \textit{E}\\
\hspace*{1.0 cm}   Recopier \textit{E[i]} fois le nombre \textit{i} dans le tableau trié\\
Lire le tableau \textit{E} dans l'ordre croissant
\end{tcolorbox}



\newpage
\subsection{Exemple}
\hspace{1.0 cm} Afin d'illustrer cet algorithme nous allons dérouler un exemple de son utilisation.
Soit le tableau d’entier : 9, 7, 1, 4, 8, 1, 1 que l’on souhaite trier dans l’ordre croissant en utilisant le tri par dénombrement.
Dans un premier temps nous allons créer notre tableau des effectifs H puis nous allons le parcourir et recopier les valeurs dans le tableau trié :

\vspace{0.5 cm}
\hspace{3.0 cm}
\begin{tabular}{|l|c|c|r|}
  \hline
  i & H[i]  & Action & Tableau trié \\
  \hline
  0 &	0 &	on ne fait rien &\\
  1 &	3 &	on ajoute trois fois 1 &	1 1 1\\
  2 &	0 &	on ne fait rien &	1 1 1\\
  4 &	1 &	on ajoute une fois 4&	1 1 1 4\\
  4 &	0& 	on ne fait rien &	1 1 1 4\\
5 &	0 &	on ne fait rien &	1 1 1 4\\
7 &	1 &	on ajoute une fois 7 &	1 1 1 4 7\\
7 &	0 &	on ne fait rien  &	1 1 1 4 7\\
9 &	2& 	on ajoute deux fois 9 &	1 1 1 4 7 9 9\\
  \hline
\end{tabular}


\vspace{1.0 cm}
On a atteint le maximum de notre tableau des effectifs H, notre tableau est donc trié : 1, 1, 1, 4, 7, 9, 9.




\newpage 
\subsection{Complexité}



\hspace{1.0 cm}  Notons \textit{n} la taille de la liste considérée. Le calcul du minimum et du maximum coûte un parcourt de la liste, soit \textit{Θ(n) }et l'allocation de l'histogramme Θ\textit{(m)} où m désigne l'étendue de la liste \textit{L}. Notons \textit{H} l'histogramme, la construction de celui-ci demande un nouveau parcourt de la liste et à donc un coût de \textit{Θ(n)}. Pour la reconstruction de la liste dans la boucle on vide chacun des \textit{H[i]} et on sait que : 


\hspace{6.0 cm}\large\sum\limits_{i=1}^{maxL−minL+1}  H[i]=n \\


\normalsize donc la reconstruction de la liste coûte elle aussi \textit{Θ(n)}.


\normalsize Les seules opérations que l'on effectue dans notre fonction se font en temps linéaire. L'initialisation du tableau des effectifs se fait en \textit{O(n)} avec n la taille de la liste en entrée et la copie des éléments dans notre tableau trié en \textit{O(m)} avec m correspondant à max.


La complexité de l'algorithme de tri par dénombrement \textit{T} pour une liste \textit{L} de taille \textit{n} et d'étendue \textit{m} est : 


\hspace{6.0 cm}\large T(n,m)=Θ(n+m) \\ 


\normalsize Cet algorithme n'est donc linéaire que si la taille \textit{m} de l'histogramme reste raisonnable O(n) au regard de la taille de la liste, autrement dit quand la dispersion est faible et dans ce cas \textit{T(n,m)=Θ(n).} C'est la dispersion qui conditionnera l'utilisation ou non de ce tri. 




La complexité finale de notre algorithme est donc \textit{O(n+m)}, soit une complexité en temps linéaire.

\newpage
\subsection{Avantages et inconvénients}


\vspace{0.5 cm}

\begin{tabular}{l}
  \hline
  Points positifs  \\
  \hline 
  \vspace{0.1 cm} \\
\vspace{0.5 cm}     - Très efficace si les n nombres à trier son petits (<= n). &
      
 \vspace{0.5 cm}    - Ne fait aucune comparaison. & 
      
    \vspace{0.5 cm} - Peut optimiser d'autre algorithme de tri, tel que le tri par base. & 
\vspace{0.5 cm}     - Stable puisqu’il préserve l’ordre initial dans le tableau
     
  \hline

\end{tabular}

\begin{tabular}{l}
  \hline 
  Points négatifs  \\
  \hline
  \vspace{0.1 cm} \\
 \vspace{0.5 cm}    - S'exécute uniquement sur des nombres entiers. &
      
   - La complexité en mémoire est mauvaise car l'algorithme peut prendre très vite \\ beaucoup de place.
     le tableau des effectifs E a pour taille \\ la valeur maximale du tableau, or si cette valeur est très grande, \\
\vspace{0.5 cm}      le tableau H prendra énormément de place en mémoire. &
      
   - Si les valeurs du tableau sont éloignées entre elles, alors beaucoup d’espace \\ 
\vspace{0.5 cm}  mémoire restera inutilisé. & 
 
  \hline

\end{tabular}

\vspace{0.5 cm} 
Cet algorithme est donc très efficace mais il faut savoir faire un choix entre rapidité et stockage, en plus de ne pouvoir l'utiliser que sur des nombre entiers.
 
\pagebreak



\newpage
\section{Tri lexicographique}
\subsection{Description}

\hspace{1.0 cm} L'ordre lexicographique est la manière d'organiser les mots en se basant sur l'ordre alphabétique. Il rappelle la façon de rechercher un mot dans un dictionnaire : nous commençons par chercher la première lettre du mot puis la seconde, et ainsi de suite.
Le tri lexicographique prend donc en paramètre une liste de mots à trier. Chacun des mots sont créés au hasard et la liste est au départ non triée. Le nombre de mots dans la liste est choisie et donnée en paramètre. Plus il y a de mots, plus le tri mettra du temps. 
L'algorithme parcourt la liste en prenant le premier mot et en le comparant au reste des mots, lettre par lettre. Le mot est ensuite placé dans la liste suivant l'ordre alphabétique.

Nous avons ainsi le pseudo-code suivant :

\begin{tcolorbox}
Créer une nouvelle liste de mots, non triée \\
 

Pour chaque mot de la liste\\
\hspace*{1.0 cm} Comparaison du mot avec le reste de la liste et replace le mot dans la liste\\

Retourne la liste triée\\
\end{tcolorbox}

\subsection{Exemple}
\hspace{1.0 cm} En vue de mieux comprendre l'algorithme, nous allons l'utiliser sur une liste de mots $ L_{i} $ : (xyz, abc, Ade). La liste de mots sera modifiée pour donner à la fin la liste triée.

\vspace{0.5 cm}

\begin{tabular}{|l|c|r|}
  \hline
  i & Action & Liste \\
  \hline
  0 &		on va comparer le premier mot au suivant & (xyz, abc, Ade)\\
  1 &		on va comparer ce même mot au reste de la liste &	(abc, xyz, Ade)\\
  2 &		on va comparer le nouveau premier élément au reste de la liste &	(abc, Ade, xyz)\\
  3 &		 - &	(Ade, abc, xyz)\\
  \hline
\end{tabular}

\subsection{Complexité}
\hspace{1.0 cm} Soit n la taille de la liste à trier. La  création de la liste est une opération élémentaire. Pour le triage de la liste, nous utilisons la méthode sort() du langage python. Sa complexité est de l'ordre de O(n log n). La complexité de l'algorithme est donc de l'ordre de O(n log n) dans un cas moyen et dans le pire des cas.

\subsection{Avantages et inconvénients}
\hspace{1.0 cm} En ce qui concerne les point positifs, cet algorithme reste constant dans sa complexité en temps, même avec une liste assez grande. De plus, la liste est triée dans cette même liste, la mémoire requise pour le tri n'excède donc pas la taille de la liste.

Cependant, le tri ne se fait que sur des mots. On peut également rajouter que la complexité en temps n'est plus linéaire mais linéarithmique. 

\newpage





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Conception}
\newpage 

\section{Résultats}
\newpage 
\section{Organisation}
\newpage 
\section{Conclusion}

\newpage
%\bibliographystyle{plain}
%\bibliography{biblist}

\end{document}
